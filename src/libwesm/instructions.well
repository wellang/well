// Copyright (c) Tristan Wellman 2022

~macro:move[2] {
	asm~ mov %2, %1
}

~macro:MOVE[2] {
	asm~ mov %2, %1
}

~macro:movess[2] {
	asm~ movss %2, %1
}

~macro:MOVESS[2] {
	asm~ movess %2, $1
}

~macro:jump[1] {
	asm~ jmp %1
}

~macro:JUMP[1] {
	asm~ jmp %1
}

~macro:pop[1] {
	asm~ pop %1
}

~macro:POP[1] {
	asm~ pop %1
}

// add integers
~macro:add[2] {
 	asm~ add %2, %1
}

~macro:ADD[2] {
	asm~ add %2, %1
}

// subtract integers
~macro:sub[2] {
     	asm~ sub %2, %1
}

~macro:SUB[2] {
	asm~ sub %2, %1
}

// xor
~macro:xor[2] {
       	asm~ xor %2, %1
}

~macro:XOR[2] {
	asm~ xor %2, %1
}

// adjust after addition
~macro:aaa[0] {
        asm~ aaa
}

~macro:AAA[0] {
	asm~ aaa
}

// adjust al after subtraction
~macro:aas[0] {
	asm~ aas
}

~macro:AAS[0] {
	asm~ aas
}

// adjust ax after division
~macro:aad[1] {
	asm~ aad %1
}

~macro:AAD[1] {
	asm~ aad %1
}

// adjust ax after multiply
~macro:aam[1] {
	asm~ aam %1
}

~macro:AAM[1] {
	asm~ aam %1
}

// add with carry
~macro:adc[2] {
	asm~ adc %2, %1 
}

~macro:ADC[2] {
	asm~ adc %2, %1
}

// add packed double precision fp values
~macro:addpd[2] {
	asm~ addpd %2, %1
}

~macro:ADDPD[2] {
	asm~ addpd %2, %1
}

// add packed single precision fp values
~macro:addps[2] {
	asm~ addps %2, %1
}

~macro:ADDPS[2] {
	asm~ addps %2, %1
}

// add scalar double precision fp values
~macro:addsd[2] {
	asm~ addsd %2, %1
}

~macro:ADDSD[2] {
	asm~ addsd %2, %1
}

// add scalar single persision fp values
~macro:addss[2] {
	asm~ addss %2, %1
}

~macro:ADDSS[2] {
	asm~ addss %2, %1
}

// bitwise AND
~macro:and[2] {
	asm~ and %2, %1
}

~macro:AND[2] {
	asm~ and %2, %1
}

// bitwise logical AND NOT of packed double percision fp values
~macro:andnpd[2] {
	asm~ andnpd %2, %1
}

~macro:ANDNPD[2] {
	asm~ andnpd %2, %1
}

// bitwise logical AND NOT of packed single percision fp values
~macro:andnps[2] {
	asm~ andnps %2, %1
}

~macro:ANDNPS[2] {
	asm~ andnps %2, %1
}

// bitwise logical AND for single fp
~macro:andpd[2] {
	asm~ andpd %2, %1
}

~macro:ANDPD[2] {
	asm~ andpd %2, %1
}

// bitwise logical AND for single fp
~macro:andps[2] {
	asm~ andps %2, %1
}

~macro:ANDPS[2] {
	asm~ andps %2, %1
}

//adjust RPL fiels of selector
~macro:arpl[2] {
	asm~ arpl %2, %1
}

~macro:ARPL[2] {
	asm~ arpl %2, %1
}

// check array index against bounds
macro:bound[2] {
	asm~ bound %2, %1
}

macro:BOUND[2] {
	asm~ bound %2, %1
}

// bit scan least significant
~macro:bscanl[2] {
	asm~ bsf %2, %1
}

~macro:BSCANL[2] {
	asm~ bsf %2, %1
}

// bit scan most significant
~macro:bscanm[2] {
	asm~ bsr %2, %1
}

~macro:BSCANM[2] {
	asm~ bsr %2, %1
}

// byte swap
~macro:bswap[1] {
	asm~ bswap %1
}

~macro:BSWAP[1] {
	asm~ bswap %1
}

// bit test
~macro:bt[2] {
	asm~ bt %2, %1
}

~macro:BT[2] {
	asm~ bt %2, %1
}

~macro:btc[2] {
	asm~ btc %2, %1
}

~macro:BTC[2] {
	asm~ btc %2, %1
}

~macro:btr[2] {
	asm~ btr %2, %1
}

~macro:BTR[2] {
	asm~ btr %2, %1
}

~macro:bts[2] {
	asm~ bts %2, %1
}

~macro:BTS[2] {
	asm~ bts %2, %1
}

// sign extensions
~macro:cbw[0] {
	asm~ cbw
}

~macro:CBW[0] {
	asm~ cbw
}

~macro:cwde[0] {
	asm~ cwde
}

~macro:CWDE[0] {
	asm~ cwde
}

~macro:cwd[0] {
	asm~ cwd
}

~macro:CWD[0] {
	asm~ cwd
}

~macro:cdq[0] {
	asm~ cdq
}

~macro:CDQ[0] {
	asm~ cdq
}

// clear flags
~macro:clc[0] {
	asm~ clc
}

~macro:CLC[0] {
	asm~ clc
}

~macro:cld[0] {
	asm~ cld
}

~macro:CLD[0] {
	asm~ cld
}

~macro:clts[0] {
	asm~ clts
}

~macro:CLTS[0] {
	asm~ clts
}

// flush cache line
~macro:clflush[1] {
	asm~ clflush %1
}

~macro:CLFLUSH[1] {
	asm~ clflush %1
}

// complement carry flag
~macro:cmc[0] {
	asm~ cmc
}

~macro:CMC[0] {
	asm~ cmc
}

// conditional move
~macro:cmove[2] {
	asm~ cmov %2, %1
}

~macro:CMOVE[2] {
	asm~ cmov %2, %1
}

~macro:cmovecc[2] {
	asm~ cmovcc %2, %1
}

~macro:CMOVECC[2] {
	asm~ cmovcc %2, %1
}

// // // // // // // // // //
// TODO: compare strings   //
// // // // // // // // // //

// get CPU identification code
~macro:cpuid[0] {
	asm~ cpuid
}

~macro:CPUID[0] {
	asm~ cpuid
}

// packed signed int32 to packed double percision fp conversion
~macro:cvtdq2pd[2] {
	asm~ cvtdq2pd %2, %1
}

~macro:CVTDQ2PD[2] {
	asm~ cvdq2pd %2, %1
}

// packed signed int32 to packed single percision fp conversion
~macro:cvtdq2ps[2] {
	asm~ cvtdq2ps %2, %1
}

~macro:CVTDQ2PS[2] {
	asm~ cvtdq2ps %2, %1
}

// packed double percision to packed signed int32 conversion
~macro:cvtp2dq[2] {
	asm~ cvtp2dq %2, %1
}

~macro:CVTP2DQ[2] {
	asm~ cvtp2dq %2, %1
}

// packed double precision fp to packed signed int32 conversion
~macro:cvtpd2pi[2] {
	asm~ cvtpd2pi %2, %1
}

~macro:CVTPD2PI[2] {
	asm~ cvtpd2pi %2, %1
}

